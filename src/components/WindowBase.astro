---
/** WindowBase: Base component for all draggable windows */
interface Props {
	title: string;
	x?: number;
	y?: number;
	width?: number;
	height?: number;
	zIndex?: number;
	windowId: string;
	initiallyVisible?: boolean;
}

const {
	title,
	x = 20,
	y = 20,
	width = 400,
	height = 300,
	zIndex = 10,
	windowId,
	initiallyVisible = true,
} = Astro.props as Props;
---

<div
	class="window-component resize-drag"
	id={windowId}
	style={`left: ${x}px; top: ${y}px; width: ${width}px; height: ${height}px; z-index: ${zIndex};${initiallyVisible ? '' : ' display:none;'}`}
	data-x="0"
	data-y="0"
>
	<div class="window-frame">
		<div class="window-titlebar" data-drag-handle>
			<button class="window-close-btn" type="button" aria-label="Cerrar"
				>×</button
			>
			<span class="window-title-text">{title}</span>
			<button class="window-zoom-btn" type="button" aria-label="Zoom"></button>
		</div>
		<div class="window-body">
			<slot />
		</div>
	</div>
	<div class="window-resize-handle"></div>
</div>

<script is:inline define:vars={{ windowId }}>
	(function () {
		const windowEl = document.getElementById(windowId);
		const titleBar = windowEl.querySelector("[data-drag-handle]");
		const closeBtn = windowEl.querySelector(".window-close-btn");
		const zoomBtn = windowEl.querySelector(".window-zoom-btn");
		let savedRect = null;
		let zoomed = false;
		let shaded = false;
		let savedHeight = null;
		const bodyEl = windowEl.querySelector('.window-body');

		function emitFocused() {
			try {
				const title =
					windowEl.querySelector(".window-title-text")?.textContent || "";
				window.dispatchEvent(
					new CustomEvent("window-focused", { detail: { id: windowId, title } })
				);
			} catch {}
		}

		// Visibility manager (singleton on window)
		function ensureManager() {
			// @ts-ignore
			let wm = window.__windowManager;
			if (!wm) {
				wm = {
					_v: {},
					register(id, visible) {
						this._v[id] = !!visible;
						try {
							window.dispatchEvent(
								new CustomEvent("window-visibility-change", {
									detail: { id, visible: !!visible },
								})
							);
						} catch {}
					},
					setVisible(id, visible) {
						this._v[id] = !!visible;
						try {
							window.dispatchEvent(
								new CustomEvent("window-visibility-change", {
									detail: { id, visible: !!visible },
								})
							);
						} catch {}
					},
					isVisible(id) {
						return !!this._v[id];
					},
					toggle(id) {
						this.setVisible(id, !this.isVisible(id));
					},
				};
				// @ts-ignore
				window.__windowManager = wm;
			}
			return wm;
		}
		const manager = ensureManager();

		// Helpers
		function getCanvas() {
			let el = windowEl.parentElement;
			while (el && !el.hasAttribute("data-desktop-canvas")) el = el.parentElement;
			return el || document.body;
		}

		function bringToFront() {
			const allWindows = document.querySelectorAll(".window-component");
			let maxZ = 10;
			allWindows.forEach((w) => {
				const z = parseInt(w.style.zIndex) || 10;
				if (z > maxZ) maxZ = z;
			});
			windowEl.style.zIndex = (maxZ + 1).toString();
			emitFocused();
		}

		// Zoom behavior (toggle between saved rect and fit-to-canvas)
		function doShadeToggle(){
			if (!shaded){
				savedHeight = windowEl.style.height || (windowEl.offsetHeight + 'px');
				const tb = windowEl.querySelector('.window-titlebar');
				const th = tb ? tb.offsetHeight : 18;
				if (bodyEl) bodyEl.style.display = 'none';
				windowEl.style.height = th + 'px';
				shaded = true;
			} else {
				if (bodyEl) bodyEl.style.display = '';
				if (savedHeight) windowEl.style.height = savedHeight;
				shaded = false;
			}
			bringToFront();
		}
		// Double-click title bar to shade/unshade
		titleBar.addEventListener('dblclick', (e)=>{
			const t = e.target;
			if (t instanceof Element && t.closest('.window-close-btn, .window-zoom-btn')) return;
			doShadeToggle();
		});

		function doZoomToggle() {
			const canvas = getCanvas();
			if (!zoomed) {
				// Save current geometry (including transform offsets)
				const rect = {
					left: parseFloat(windowEl.style.left) || 0,
					top: parseFloat(windowEl.style.top) || 0,
					width: parseFloat(windowEl.style.width) || windowEl.offsetWidth,
					height: parseFloat(windowEl.style.height) || windowEl.offsetHeight,
					x: parseFloat(windowEl.getAttribute("data-x")) || 0,
					y: parseFloat(windowEl.getAttribute("data-y")) || 0,
				};
				savedRect = rect;
				// Reset transform and expand to canvas with small padding
				windowEl.style.transform = "translate(0px, 0px)";
				windowEl.setAttribute("data-x", "0");
				windowEl.setAttribute("data-y", "0");
				const pad = 8;
				const cw = canvas.clientWidth;
				const ch = canvas.clientHeight;
				windowEl.style.left = pad + "px";
				windowEl.style.top = pad + "px";
				windowEl.style.width = Math.max(280, cw - pad * 2) + "px";
				windowEl.style.height = Math.max(140, ch - pad * 2) + "px";
				zoomed = true;
				bringToFront();
			} else if (savedRect) {
				windowEl.style.left = savedRect.left + "px";
				windowEl.style.top = savedRect.top + "px";
				windowEl.style.width = savedRect.width + "px";
				windowEl.style.height = savedRect.height + "px";
				windowEl.style.transform = `translate(${savedRect.x}px, ${savedRect.y}px)`;
				windowEl.setAttribute("data-x", String(savedRect.x));
				windowEl.setAttribute("data-y", String(savedRect.y));
				zoomed = false;
				bringToFront();
			}
		}
		zoomBtn.addEventListener("click", doZoomToggle);

		// Initialize Interact.js following the exact documentation pattern
		function initInteract() {
			if (!window.interact) return;

			const interact = window.interact;

			// Instancia por ventana (evita re-configurar todas cada vez)
			const i = interact(windowEl);

			// Resize sólo desde derecha e inferior para no interferir con el title bar
			i.resizable({
				edges: { left: false, right: true, bottom: true, top: false },
				listeners: {
					move(event) {
						var target = event.target;
						var x = parseFloat(target.getAttribute("data-x")) || 0;
						var y = parseFloat(target.getAttribute("data-y")) || 0;
						target.style.width = event.rect.width + "px";
						target.style.height = event.rect.height + "px";
						// left/top deltas sólo relevantes si esos edges activos (no lo están, pero dejamos por consistencia)
						x += event.deltaRect.left;
						y += event.deltaRect.top;
						target.style.transform = `translate(${x}px, ${y}px)`;
						target.setAttribute("data-x", x);
						target.setAttribute("data-y", y);
					},
				},
				modifiers: [
					interact.modifiers.restrictEdges({ outer: "parent" }),
					interact.modifiers.restrictSize({ min: { width: 280, height: 140 } }),
				],
				inertia: true,
			});

			// Drag sólo sobre la barra de título moviendo la ventana completa
			interact(titleBar).draggable({
				ignoreFrom: ".window-close-btn",
				listeners: {
					start() {
						bringToFront();
						titleBar.style.cursor = "grabbing";
					},
					move(e) {
						const x = (parseFloat(windowEl.getAttribute("data-x")) || 0) + e.dx;
						const y = (parseFloat(windowEl.getAttribute("data-y")) || 0) + e.dy;
						windowEl.style.transform = `translate(${x}px, ${y}px)`;
						windowEl.setAttribute("data-x", x);
						windowEl.setAttribute("data-y", y);
					},
					end() {
						titleBar.style.cursor = "move";
					},
				},
				inertia: true,
				modifiers: [
					interact.modifiers.restrictRect({
						restriction: "parent",
						endOnly: true,
					}),
				],
			});
		}

		// Close button functionality: only hide and update manager
		closeBtn.addEventListener("click", () => {
			if (windowEl.style.display !== "none") {
				windowEl.style.display = "none";
				manager.setVisible(windowId, false);
			}
		});

		// React to visibility changes from the dock
		window.addEventListener("window-visibility-change", (e) => {
			var detail = (e && e.detail) || {};
			if (detail.id !== windowId) return;
			if (detail.visible) {
				windowEl.style.display = "block";
				bringToFront();
			} else {
				windowEl.style.display = "none";
			}
		});

		// Click to bring to front
		windowEl.addEventListener("mousedown", bringToFront);

		// Register initial visibility
		manager.register(windowId, windowEl.style.display !== "none");
		// Emit focused for the first visible window (best-effort)
		if (windowEl.style.display !== "none") {
			emitFocused();
		}

		// Initialize when Interact.js is ready
		if (window.interact) {
			initInteract();
		} else {
			window.addEventListener("load", () => {
				if (window.interact) {
					initInteract();
				}
			});
		}
	})();
</script>

<style is:inline>
	.window-component {
		position: absolute;
		background: var(--white);
		border: var(--border);
		border-radius: 0;
		box-shadow: none;
		min-width: 280px;
		min-height: 140px;
		user-select: none;
	}

	.window-frame {
		height: 100%;
		display: flex;
		flex-direction: column;
	}

	.window-titlebar {
		height: 18px;
		display: flex;
		align-items: center;
		gap: var(--space-2);
		padding: 0 var(--space-2);
		font-size: var(--fs-12);
		font-weight: 700;
		background: repeating-linear-gradient(
			45deg,
			var(--gray-25) 0 1px,
			var(--white) 1px 2px
		);
		border-bottom: var(--border);
		cursor: move;
		user-select: none;
		position: relative;
	}

	.window-close-btn {
		width: 11px;
		height: 11px;
		border: var(--border);
		background: var(--white);
		padding: 0;
		line-height: 0;
		color: transparent;
		box-shadow:
			inset -1px -1px 0 0 var(--gray-75),
			inset 1px 1px 0 0 var(--highlight);
		cursor: pointer;
		flex-shrink: 0;
	}

	.window-title-text {
		/* centrado absoluto */
		position: absolute;
		left: 50%;
		transform: translateX(-50%);
		font-weight: 700;
		pointer-events: none;
		white-space: nowrap;
		text-align: center;
	}

	.window-zoom-btn{
		position: absolute;
		right: 2px;
		top: 2px;
		width: 11px; height: 11px;
		border: var(--border);
		background: var(--white);
		box-shadow: inset -1px -1px 0 0 var(--gray-75), inset 1px 1px 0 0 var(--highlight);
		padding:0; line-height:0; color:transparent;
		cursor: pointer;
	}
	.window-zoom-btn:active{
		box-shadow: inset 1px 1px 0 0 var(--gray-75), inset -1px -1px 0 0 var(--highlight);
	}

	.window-body {
		flex: 1;
		padding: var(--space-4);
		font-size: var(--fs-10);
		line-height: var(--lh-ui);
		overflow: auto;
	}

	.window-resize-handle {
		position: absolute;
		right: 0;
		bottom: 0;
		width: 12px;
		height: 12px;
		cursor: nw-resize;
		background: linear-gradient(135deg, transparent 50%, var(--gray-75) 50%);
		pointer-events: all;
	}

	@media (max-width: 768px) {
		.window-titlebar {
			cursor: default;
		}
		.window-resize-handle {
			display: none;
		}
	}
</style>
